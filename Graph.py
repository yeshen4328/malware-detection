import pickle
import copy
from gensim.models.doc2vec import Doc2Vec
from LocalClass import readsensitive
entrypoinrt = pickle.load(open('./entrypoint.pkl','rb'))
sensitiveApiList = readsensitive()
lastSensiId = -1
lastBadPos = -1

class CallGraph:
    def __init__(self, name, matrix, dict1, main,vnum, label):
        self.appName = name
        self.graphMatrix = matrix
        self.index2methods = dict1
        self.dummyMain_index = main
        self.vertexNum = vnum
        self.label = label
def extract(x):
    x1 = x.split(' ')[0]
    x2 = x.split(' ')[1]
    x3 = x.split(' ')[2]
    x3 = x3[0:x3.find('(')]
    return x1+x3
def buildgraph(graphtxt_path,label):
    graph_in_path = graphtxt_path
    methods2index = {}
    index2methods = {}
    index = 0
    with open(graph_in_path, 'r') as lines:
        for line in lines:
            parts = line.split('==>')
            caller = parts[0]
            callees = parts[1]
            # process caller
            caller = caller.replace('<', '').replace('>', '').strip()
            if (not caller in methods2index):
                methods2index[caller] = index
                index2methods[index] = caller
                index = index + 1
            # process callee
            callees = callees.replace('\\n', '').split(', ')
            for callee in callees:
                callee = callee.replace('[\'<', '').replace('>\']\n', '').replace('\'<', '').replace('>\'', '').strip()
                #print(callee)
                if (not callee in methods2index):
                    methods2index[callee] = index
                    index2methods[index] = callee
                    index = index + 1
    graphMatri = [[0 for i in range(len(methods2index))] for i in range(len(methods2index))]

    with open(graph_in_path, 'r') as lines:
        for line in lines:
            parts = line.split('==>')
            caller = parts[0]
            callees = parts[1]
            # process caller
            caller = caller.replace('<', '').replace('>', '').strip()
            callees = callees.replace('\\n', '').split(', ')
            for callee in callees:
                callee = callee.replace('[\'<', '').replace('>\']\n', '').replace('\'<', '').replace('>\'', '').strip()
                graphMatri[methods2index[caller]][methods2index[callee]] =  1

    callgraph = CallGraph("", graphMatri, index2methods, methods2index['dummyMainClass: void dummyMainMethod(java.lang.String[])'],len(index2methods),label)
    methods2index = None
    return callgraph
api2vec = Doc2Vec.load('apimodel')
def traverse(apk_graph_path, label,packages):
    graph = buildgraph(apk_graph_path, label)
    dummyMain = graph.dummyMain_index
    path = []
    namepath = []
    sum_path = []
    #travese the graph
    for i in range(graph.vertexNum):
        if(graph.graphMatrix[dummyMain][i] == 1):
            methodname = graph.index2methods[i]
            #vec = getMethodVec(methodname,packages)
            _methodname = methodname.split(': ')[1]
            if(_methodname in entrypoinrt):
                path.append(i)
                namepath.append(methodname)
                global lastSensiId ,lastBadPos
                lastSensiId = -1
                lastBadPos = -1
                dfs(graph=graph, vertex=i, path=path,sum_path=sum_path,packages=packages, namepath = namepath)
    graph.graphMatrix = None
    return sum_path, graph.index2methods

def dfs(graph, vertex, path, sum_path, packages, namepath):
    leaf = True
    for i in range(graph.vertexNum):
        if(vertex != i and graph.graphMatrix[vertex][i] == 1 and not i in path):
            leaf = False
            methodname = graph.index2methods[i]
            namepath.append(methodname)
            # print(methodname)
            #vec = getMethodVec(methodname,packages)
            path.append(i)
            dfs(graph, i, path, sum_path,packages,namepath)
    if(leaf and len(path) > 1):
        if(containsSensitiveApi(namepath)):
            print(namepath)
            sum_path.append(copy.deepcopy(path))
    global lastBadPos # ***********************************
    lastBadPos = max(0, lastBadPos - 1)
    path.pop()
    namepath.pop()
    return
def containsSensitiveApi(path):
    global lastSensiId, lastBadPos
    if(not lastSensiId == -1 and lastSensiId in path):
        return True
    if(not lastBadPos == -1):
        i = lastBadPos + 1
        while(i < len(path)):
            api = extract(path[i])
            if (api in sensitiveApiList):
                lastSensiId = i
                return True
            i += 1
    else:
        for i, api in enumerate(path):
            api = extract(api)
            if (api in sensitiveApiList):
                lastSensiId = i
                return True
    lastBadPos = len(path) - 1
    return False
def getMethodVec(apicall,packages):
    if(isFramwrokApis(apicall,packages)):
        classes = apicall.split(': ')[0]
        method = apicall.split(': ')[1]
        classes = classes.split('.')
        # return_type = method.split(' ')[0].split('.')
        method_name = method.split(' ')[1].split('(')[0]
        sentence = classes + [method_name]
    else:
        sentence = ['selfdefined']
    vec = api2vec.infer_vector(sentence)
    return vec

def isFramwrokApis(api , packages):
    for line in packages:
        if api.startswith(line):
            return True
    return False